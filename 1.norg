@document.meta
title: herbstclient in julia
description: some description
authors: david josephs
categories: 
created: 2022-07-15
version: 0.0.11
tangle: {
    languages: {
        julia: ./src/hc.jl
    }
    scope: all
}
@end

#tangle ./src/blog.jl
@code julia
module blog
include("hc.jl")
end
@end

* Herbstclient configuration in julia

  Lets make a thing for configuring herbstluftwm in julia!!

  First, we will make this all a module:


  Next, we will create a type which stores an expression as a command:

#tangle ./src/CmdOperator.jl
@code julia 
struct Op{T}
  operation::T
end
Op(s::Union{Symbol, String, Number, Expr}) = Op(`$(s)`)

@end

  And then some dispatches for it:

#tangle ./src/CmdOperator.jl
@code julia 
function _splitter(delim)
  return (x,y) -> `$(x) $(delim) $(y)` 
end
_chainer = _splitter(` . `)
_spacer = _splitter(` `)

(o::Op)() = `$(o.operation)` 
(o::Op)(x) =  _spacer(o.operation, x)
(o::Op)(x...)= reduce(_spacer, [x...]; init = o())
@end

  Finally, lets define some macros for creating operators!

#tangle ./src/CmdOperator.jl
@code julia 

macro op(x)
  return Op(x)
end

macro op(x::Vararg{Union{Symbol, String, Number, Expr}})
  Op(reduce( _spacer, [x...]))
end



@end



* Actually configuring


  #tangle ./src/scratch.jl
  @code julia
  ###
  ### macros and structs
  ###
  
  struct Op{T}
      operation::T
  end
  Op(s::Union{Symbol, String, Number, Expr}) = Op(`$(s)`)
  
  function _splitter(delim)
      return (x,y) -> `$(x) $(delim) $(y)` 
  end
  _chainer = _splitter(` . `)
  _spacer = _splitter(` `)
  
  (o::Op)() = `$(o.operation)` 
  (o::Op)(x) =  _spacer(o.operation, x)
  (o::Op)(x...)= reduce(_spacer, [x...]; init = o())
  chain(x) = x
  chain(x...)= reduce(_chainer, [x...]; init = `chain`)
  
  macro op(x)
      return Op(x)
  end
  macro op(x::Symbol)
      return Op(x)
  end
  macro op(x::Expr)
      return Op(eval(x))
  end
  # TODO: Look up some the type system

  _transform(x) = isa(x, Expr) ? eval(x) : x
  macro op(x::Vararg{Union{Symbol, String, Number, Expr}})
      vars = map(_transform, [x...])
      Op(reduce( _spacer, vars))
  end

  
  
  ###
  ### configuration
  ###
  super(x) = `Mod4-$(x)`
  super(x...) = reduce((x,y) -> `$(x)-$(y)`, [x...]; init=`Mod4`)
  
  hc = @op herbstclient
  k = @op hc(:keybind) super(:backspace) damn "hot" 4 (@op hc(:unlock))((chain(super(5), :ok, :wow)))
  k2 = @op herbstclient keybind
  rename = @op hc(:rename)
  
  commands = [rename(:default, tags[1])]
  
  function make_virtual_monitor(name, key)
      [hc(:add, name),
          k(super(key), :use_index, name-1)]
  end
  
  
  tags = collect(1:9)
  vms = make_virtual_monitor.(tags, tags)
  commands = vcat(commands, vcat(vms...))
  
  # rotate frames in current monitor
  rotate(n) = chain(:lock, repeat([:rotate], n)..., :unlock)
  
  keybinds = [
  (super(:slash), :spawn, "~/scripts/menus/system-menu.sh"),
  (super(:Shift, :q), :spawn, "~/scripts/menus/locker.sh"),
  (super(:Shift, :r), :reload),
  (super(:y), rotate(3)),
  (super(:Alt, :y), rotate(2)),
  (super(:Shift, :y), rotate(1))
  ]
  commands = vcat(commands, ( ((x) -> k(x...)).(keybinds) ))
  
  commands
  
  run(hc(rotate(3)))
  @end
  
  

